# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48309644/)
```
基本信息
#:48309644
题目:P0900
提交人:2400090404_李实
内存:3668kB
时间:115ms
语言:Python3
提交时间:2025-02-19 16:09:28
```
### 最长上升子序列（LIS）
所谓子序列，就是从数组中选择一些数，且顺序和数组中的顺序是一样的，比如\[1,6,7,2,4,5,3\]中\[2,5,3\]就是这个数组的一个子序。\
本题的要求是严格递增子序列，这点还请注意。我们要做的就是在所有严格递增子序列里找到最长的那个，并输出它的长度。比如\[1,6,7,2,4,5,3\]输出的答案就是\[1，2,5,3\]

由于子序列本质上就是数组的一个子集，那我们可以从子集型回溯的角度来思考（选与不选），对于子集型回溯，我们有选与不选，或者枚举哪个两种思路，前者在顺序结构中调用两个递归，后者则在一层递归里进行循环遍历。\
以\[1,6,7,2,4,5,3\]为例子\
我们倒着思考，如果3是子序列的最后一个数字，考虑选或不选，那前面的数字就需要和3比大小，所以除了直到当前下标以外，我们还需要知道上一个数字的下标，而如果考虑枚举选哪个，我们就可以直接枚举前面的比3小的数字，当作子序列的倒数第二个数，那只需要知道当前所选数字的下标即可，因此枚举只需要一个参数，更好写。
#### 思路1
枚举nums\[i\]作为LIS的末尾元素 那么需要枚举nums\[j\]作为LIS倒数第二个元素，其中j<i且nums\[j\]<nums\[i\]\
那么我们回溯时的子问题就是以nums\[i\]结尾的LIS长度，而当前操作就将是枚举nums\[j\]而下一个子问题就是以nums\[j\]结尾的LIS长度
### 递归状态转移方程
$$ 
dfs(i) = max{dfs(j)} + 1   j < i   且nums\[j\]<nums\[i\]
$$ 
```python
def LIS(nums):
    n = len(nums)
    mem = [-1]*n#这里加一个记忆化搜索 变成动态规划
    def dfs(i):#以i结尾的子序列长度
        res = 0
        if mem[i] != -1:
            return mem[i]
        for j in range(i):#枚举i前面的j ！注意这里不需要写边界条件 因为当i=0时range（i）是不会执行的
            if nums[j] < nums[i]:#如果nums[j]<nums[i]
               res = max(res, dfs(j))#那就进行递归
        mem[i] =  res + 1
        return mem[i]

    return max(dfs(i) for i in range(n))
```
#### 时间复杂度
$$
O(n)个状态，每个状态需要O(n)时间所以算法复杂度为O(n^2)
$$
### 递推状态转移方程：
$$ 
f[i] = max{f[j]}+1     j < i     且nums\[j\]<nums\[i\]
把dfs改成数组，把递归改成循环
$$ 
```python
def LIS_d(nums):
    n = len(nums)
    f = [0]*n
    for i,x in enumerate(nums):
        res = 0
        for j in range(i):
            if nums[j] < x:
                res = max(f[j],res)
        f[i] = res + 1
    return f[n-1]
```
#### 时间复杂度
$$
O(n)个状态，每个状态需要O(n)时间所以算法复杂度为O(n^2)
$$
#### 思路2
求最长上升子序列可以转换为求该数组与自然数组的最长公共子序列
因此 求nums的最大上升子序列也可以转换为 求它和numbers\[1，2，3，4，5，6....\]的最大公共子序列
先给出最长公共子序列（LCS）的代码：
```python
#递归+记忆化搜索：
def LCS(s,t):
    n = len(s)
    m = len(t)
    def dfs(i,j):
        if i < 0 or j < 0:
            return 0
        if s[i] == t[j]:
            return dfs(i-1,j-1)+1
        return max(dfs(i-1,j),dfs(i,j-1))
    return dfs(n-1,m-1)
#改递推：
def LCS_d(s,t):
    n = len(s)
    m = len(t)
    f = [[0 for i in range(m+1)]for j in range(n+1)]
    for i,x in enumerate(s):
        for j,y in enumerate(t):
            f[i+1][j+1] = f[i][j] +1 if x ==y else max(f[i+1][j],f[i][j+1])
    return f[n][m]
```
然后我们只需要生成一个足够长的自然数数组与原数组取最长公共子序列即可\
#### 时间复杂度
$$
O(n)个状态，每个状态需要O(n)时间所以算法复杂度为O(n^2)
$$
#### 思路3
这个问题在时间复杂度上可以进一步优化，对于动态规划问题可以考虑交换状态与状态值\
对于f数组我们的定义是末尾元素为nums\[i\]的LIS长度，那我们把长度和末尾元素交换一下，把一个新数组g定义成长度为定值（下标）时上升子序列的末尾元素最小值（元素）\
为什么要维护最小值呢？我们可以看一个例子\
nums= \[1,6,7,2,4,5,3\]\
我们从左到右遍历这个数组，对于1它单独形成一个长为1的上升子序列\
g=\[1]\
然后遍历到6\
虽然6也可以单独形成一个长为1的上升子序列，但6>1，所以g\[0]仍会保持1\
而由于1，6组成一个长为2的上升子序列，因此g\[1]=6\
然后遍历到7，同上有\
g = \[1,6,7]\
遍历到2，此时1，2组成一个长为2的上升子序列，且2<6 因此g\[1]=2\
遍历到4，此时有1，2，4组成一个长为3的上升子序列，因此有g\[2]=4\
遍历到5，此时有1，2，4，5，因此g=\[1,2,4,5]\
然后遍历到3  g=\[1,2,3,5]\
从这个过程可以发现，当我们把g的元素定义成上升子序列末尾元素的最小值的时候才能更方便地判断g是否会变长（只需把新元素和g末尾的元素比大小）\
按照这种定义方式，因为没有重叠子问题，所以不算动态规划，算贪心问题\
我们可以证明g是一个严格递增序列，同时每次我们要么添加一个数，要么修改一个数\
严格证明可以使用反证+数学归纳法\
因此我们算法就是用二分查找快速找到当前数字应该插入或替换到g的哪个位置\
代码如下：
```python
import bisect#二分查找
def LIS_nlogn(nums):
    g = []
    for i, x in enumerate(nums):
        j = bisect.bisect_left(g,x)
        if j == len(g):
            g.append(x)
        else:
            g[j] = x
    return len(g)
```
That's all~ 
