# 状态: [Accepted](http://dsbpython.openjudge.cn/dspythonbook/solution/48311070/)
```
基本信息
#:48311070
题目:P0880
提交人:2400090404_李实
内存:4060kB
时间:37ms
语言:Python3
提交时间:2025-02-19 18:36:20
```
## 简单背包问题
这个是一个典型的完全背包问题，特点在于每种物品都可以选择无数次，直到背包装不下。类似的典型问题有兑换硬币，分苹果等。直接用递归实现时间复杂度是指数级别的，其方法一般都是动态规划。实现途径有两种，一种是递归+记忆化搜索，另一种是直接递推，都可以把时间复杂度降低到O(n^2)
### 思路
定义递归函数dfs(i,c)其中i表示还可以当前可选择的物品下标，c表示剩余背包容量，每轮先判断当前物品是否能被背包装下，如果不能则跳过该物品，判断下一个物品。如果可以装下，那么本轮可以选择跳过或者装入该物品，于是就可以写出状态转移方程\
至于边界条件\
1.当c=0时说明恰好装满，返回1种情况\
2.当i=0且c>0说明没装满，且没有物品可装了，返回0种情况
### 递归状态转移方程(递推类似)
$$
dfs(i,c) = dfs(i-1,c) + dfs(i,c-nums[i-1])
$$

代码如下\
1.递归+记忆化搜索
```python
def Bag(nums,amount):
    k = len(nums)
    f = [[-1 for i in range(k+1)] for j in range(amount+1)]
    def dfs(i,c):
        if f[c][i] != -1:
            return f[c][i]
        if c == 0:
            return 1
        if i == 0 and c != 0:
            return 0
        if c < nums[i-1]:
            return dfs(i-1,c)
        f[c][i] = dfs(i-1,c)+dfs(i,c-nums[i-1])
        return f[c][i]
    return dfs(k,amount)
```
2.递推
```python
def Bag_d(nums,amount):
    k = len(nums)
    f =  [[0 for i in range(amount +1)] for j in range(k+1)]
    for j in range(k+1):
        f[j][0] = 1#初始条件

    for i ,x in enumerate(nums):
        for c in range(amount+1):
            if c < x:
                f[i+1][c] = f[i][c]
            else:
                f[i+1][c] = f[i][c] + f[i+1][c-x]
    return f[k][amount]
```
That's all~
